{"version":3,"file":"myVue.js","mappings":"q6CAAA,IAAIA,EAAe,KACbC,EAAU,IAAIC,QAEdC,EAAAA,WACF,c,4FAAc,SACVC,KAAKC,IAAM,IAAIC,I,wCAGnB,SAAIC,GACAH,KAAKC,IAAIG,IAAID,K,qBAGjB,WAAU,UACQH,KAAKC,KADb,IACN,4BACIE,EADoB,WADlB,oC,mBATRJ,GAgBN,SAASM,EAAOC,GACZV,EAAeU,EACfA,IACAV,EAAe,KA2CnB,SAASW,EAASC,GAiBd,OAAO,IAAIC,MAAMD,EAhBU,CACvBE,IADuB,SACnBF,EAAKG,GAEL,OA3CZ,SAAeH,EAAKG,GAChB,GAAqB,OAAjBf,EAAuB,CAClBC,EAAQe,IAAIJ,IAAMX,EAAQgB,IAAIL,EAAK,IAAIM,KAC5C,IAAIC,EAAUlB,EAAQa,IAAIF,GACrBO,EAAQH,IAAID,IAAOI,EAAQF,IAAIF,EAAM,IAAIZ,GACpCgB,EAAQL,IAAIC,GAClBP,IAAIR,IAoCJoB,CAAMR,EAAKG,GAC8B,WAAlC,EAAOM,QAAQP,IAAIF,EAAKG,IAAqBJ,EAASU,QAAQP,IAAIF,EAAKG,IAASM,QAAQP,IAAIF,EAAKG,IAE5GE,IALuB,SAKnBL,EAAKG,EAAMO,GACX,OAAKV,EAAIG,IAKTM,QAAQJ,IAAIL,EAAKG,EAAMO,GAzCnC,SAAiBV,EAAKG,GAClB,GAAId,EAAQe,IAAIJ,GAAM,CAClB,IAAIO,EAAUlB,EAAQa,IAAIF,GACtBO,EAAQH,IAAID,IACZI,EAAQL,IAAIC,GAAMQ,WAsClBA,CAAQX,EAAKG,IACN,IANHM,QAAQJ,IAAIL,EAAKG,EAAMO,GA5BvC,SAA0BV,EAAKG,GAC3B,GAAId,EAAQe,IAAIJ,GAAM,CAClB,IADkB,EACdO,EAAUlB,EAAQa,IAAIF,GACtBY,EAAU,IAAIlB,IAFA,IAGFe,QAAQI,QAAQb,IAHd,IAGlB,2BAAsC,KAA7Bc,EAA6B,QAClC,GAAIP,EAAQH,IAAIU,IAAQA,IAAQX,EAAM,CAClC,IADkC,EAC9BY,EAAaR,EAAQL,IAAIY,GAAKrB,IADA,IAEfsB,GAFe,IAElC,2BAA+B,KAAtBlB,EAAsB,QAC3Be,EAAQhB,IAAIC,GACZkB,EAAU,OAAQlB,IAJY,iCAJxB,wCAYJe,GAZI,IAYlB,2BAAuB,KAAdjB,EAAc,QACnBP,EAAeO,EACfA,KAdc,gCA4BVqB,CAAiBhB,EAAKG,IACf,M,0NC3EjBc,EAUF,WAAYC,EAAMC,EAAOC,I,4FAAU,oBAP/B,CACAC,GAAI,KACJH,KAAM,KACNI,QAASL,EAAMM,MACfC,gBAAiB,IAIjBhC,KAAK0B,KAAOA,EACZ1B,KAAK2B,MAAQA,EACb3B,KAAK4B,SAAWA,GCbxB,SAASK,EAAQ9B,GACb,OAAO+B,OAAOC,UAAUC,SAASC,KAAKlC,GAAGmC,MAAM,GAAI,GAGvD,SAASC,EAAcpC,GACnB,OAAOA,aAAaqC,aAAerC,aAAasC,KAGpD,SAASC,EAASvC,GACd,MAAsB,WAAf8B,EAAQ9B,GAGnB,SAASwC,EAAQxC,GACb,YAAa,IAANA,EAGX,SAASyC,EAAQzC,GACb,MAAmB,WAAf8B,EAAQ9B,GAC6B,IAA9Bc,QAAQI,QAAQlB,GAAG0C,OAEX,UAAfZ,EAAQ9B,GACY,IAAbA,EAAE0C,YADb,EAKJ,SAASC,EAAYC,EAAIC,GACrB,OAAOD,EAAGE,EAAEvB,OAASsB,EAAGC,EAAEvB,KCjB9B,SAASwB,EAAExB,GAAiC,IAA3BC,EAA2B,uDAAnB,GAAIC,EAAe,uDAAJ,GAChCuB,EAAqB,KAATzB,EAAcD,EAAM2B,KAAKC,KAAO5B,EAAM2B,KAAKE,QACtDV,EAAQhB,KACTA,EAAWA,EAAS2B,KAAI,SAAAC,GACpB,OAAId,EAASc,GAAeN,EAAE,GAAI,CAC9BO,KAAMD,GACP,IACIA,MAGf,IAAIE,EAAM,IAAIjC,EAAMC,EAAMC,EAAOC,GAEjC,OADA8B,EAAIT,EAAEvB,KAAOyB,EACNO,E,0GCZX,SAASC,EAAGC,EAAWC,GAEnB,OADInB,EAASkB,KAAYA,EAAYD,EAAGG,SAAUF,IAC3CA,EAAUG,cAAcF,GAkBnC,SAASG,EAAOC,EAAML,GACdlB,EAASkB,KACTA,EAAYE,SAASC,cAAcH,IAEnCrB,EAAcqB,IAAYA,EAAUM,YAAYD,GAGxD,SAASE,EAAOF,EAAML,EAAWQ,GAC7B,IAAK7B,EAAc0B,GAAO,MAAM,IAAII,MAAM,6CAO1C,GANI3B,EAASkB,KACTA,EAAYD,EAAGG,SAAUF,IAEzBrB,EAAcqB,IAAclB,EAAS0B,KACrCA,EAAST,EAAGC,EAAWQ,IAEvB7B,EAAcqB,IAAcrB,EAAc6B,GAAS,CACnD,IADmD,EAC/CE,GAAU,EADqC,E,25BAAA,CAErCV,EAAUW,YAF2B,IAEnD,2BACI,GADgC,UACtBH,EAAQ,CACdE,GAAU,EACV,OAL2C,8BAQnD,IAAIA,EACC,MAAM,IAAID,MAAJ,kDADET,EAAUY,aAAaP,EAAMG,IAKlD,SAASK,EAAGR,EAAML,GACdA,EAAUc,YAAYT,GAG1B,SAASU,EAAQV,EAAMW,EAAM1D,GACzB,IAAKwB,EAASkC,GAAO,MAAM,IAAIP,MAAJ,0BAE3B,GADI3B,EAASuB,KAAOA,EAAON,EAAGG,SAAUG,KACnC1B,EAAc0B,GAAO,MAAM,IAAII,MAAJ,0CAChC,GAAuC,OAAnCO,EAAKC,cAAcvC,MAAM,EAAG,GAAa,CAEzC,GAAuB,aAAnBL,EAAQf,GAAuB,MAAM,IAAImD,MAAJ,sDACzC,IAAIS,EAAQF,EAAKtC,MAAM,GAAGuC,cAC1BZ,EAAKc,oBAAoBD,EAAO5D,GAChC+C,EAAKe,iBAAiBF,EAAO5D,QAE7B0D,ECxER,SAAiBK,GACb,GAAmB,iBAARA,EAAkB,MAAO,GAEpC,IADA,IAAIC,EAAMD,EAAIE,MAAM,IACXC,EAAMH,EAAIpC,OAAS,EAAGuC,GAAO,EAAGA,IACjCF,EAAIE,IAAQ,KAAOF,EAAIE,IAAQ,MAC/BF,EAAIE,GAAOF,EAAIE,GAAKP,cACpBK,EAAIG,OAAOD,EAAK,EAAG,MAG3B,OAAOF,EAAII,KAAK,ID+DLC,CAAQX,GACfX,EAAKuB,aAAaZ,EAAM1D,GAIhC,SAASuE,EAAOxB,EAAMW,GAClB,IAAKlC,EAASkC,GAAO,MAAM,IAAIP,MAAJ,0BAE3B,GADI3B,EAASuB,KAAOA,EAAON,EAAGG,SAAUG,KACnC1B,EAAc0B,GAAO,MAAM,IAAII,MAAJ,0CAChCJ,EAAKyB,gBAAgBd,GAGzB,SAASe,EAAK1B,EAAML,EAAWQ,GAC3BK,EAAGR,EAAML,GACTO,EAAOF,EAAML,EAAWQ,G,ugCEzE5B,SAASwB,EAAMC,EAAOjC,EAAWQ,GAK7B,GAJIzB,EAAQkD,KACRC,QAAQC,KAAR,mHACAF,EAAQ3C,EAAE,GAAI,GAAI,CAAC,eAEnB2C,EAAM5C,EAAEvB,KAAOD,EAAM2B,KAAKE,QAAS,CACnC,IAAI0C,EAAMH,EAAMnE,KAChB,EAGImE,EAFAlE,EADJ,EACIA,MACAC,EAFJ,EAEIA,SAEAC,EFTZ,SAAYmE,GACR,OAAOlC,SAASmC,cAAcD,GEQjBE,CAAOF,GAEhB,GADAH,EAAM5C,EAAEpB,GAAKA,GACRe,EAAQjB,GAAQ,WACAV,QAAQI,QAAQM,IADhB,IACjB,2BAAyC,KAAhChB,EAAgC,QACrCuF,EAAYrE,EAAIlB,EAAMM,QAAQP,IAAIiB,EAAOhB,KAF5B,+BAKrB,IAAKiC,EAAQhB,GAAW,WACFA,GADE,IACpB,2BACIgE,EADwB,QACX/D,GAFG,+BAKpBc,EAAQyB,GAAS8B,EAAWrE,EAAI+B,GAC/BsC,EAAWrE,EAAI+B,EAAWQ,QAC5B,GAAIyB,EAAM5C,EAAEvB,KAAOD,EAAM2B,KAAKC,KAAM,CACvC,IACIxB,GFfAoD,EEcOY,EAAMlE,MAAM8B,KFbpBK,SAASqC,eAAelB,IEe3BY,EAAM5C,EAAEpB,GAAKA,EACTc,EAAQyB,GAAS8B,EAAWrE,EAAI+B,GAC/BsC,EAAWrE,EAAI+B,EAAWQ,GFlBvC,IAAYa,E,ugCGJZ,SAASmB,EAAQrD,EAAIC,GACjB,GAAKD,EAAGE,EAAEvB,KAAOD,EAAM2B,KAAKC,MAAUL,EAAGC,EAAEvB,KAAOD,EAAM2B,KAAKC,KAGzD,OAFAN,EAAGE,EAAEpB,GAAGwE,UAAYrD,EAAGrB,MAAM8B,UAC7BT,EAAGC,EAAEpB,GAAKkB,EAAGE,EAAEpB,IAGnB,IAAIyE,EAASvD,EAAGE,EAAEpB,GAAG0E,WACjBnC,EAASrB,EAAGE,EAAEpB,GAAG2E,kBAAe,EACpCF,EAAO5B,YAAY3B,EAAGE,EAAEpB,IACxB+D,EAAM5C,EAAIsD,EAAQlC,GAGtB,SAASqC,EAAM1D,EAAIC,GACf,GAAIL,EAAQI,IAAOJ,EAAQK,GAEvB8C,QAAQC,KAAR,uHAFJ,CAKA,IAAIlE,EAAKkB,EAAGE,EAAEpB,GACd,GAAIkB,EAAGE,EAAEvB,OAASsB,EAAGC,EAAEvB,KACnB,GAAIqB,EAAGE,EAAEvB,KAAOD,EAAM2B,KAAKC,KACnBN,EAAGpB,MAAM8B,OAAST,EAAGrB,MAAM8B,KAAM2C,EAAQrD,EAAIC,GAC5CA,EAAGC,EAAEpB,GAAKA,OAEf,GAAIkB,EAAGrB,OAASsB,EAAGtB,KAAM0E,EAAQrD,EAAIC,OAChC,CAGDA,EAAGC,EAAEpB,GAAKA,EACV,IAJC,EAIG6E,EAAW1D,EAAGrB,MACdgF,EAAW5D,EAAGpB,MALjB,IAMgBV,QAAQI,QAAQqF,IANhC,IAMD,2BAA4C,KAAnC/F,EAAmC,QACpCgG,EAAShG,KAAU+F,EAAS/F,KACL,OAAnB+F,EAAS/F,GAAgB8E,EAAO5D,EAAIlB,GACnCgE,EAAQ9C,EAAIlB,EAAM+F,EAAS/F,MATvC,wCAYgBM,QAAQI,QAAQsF,IAZhC,IAYD,2BAA4C,KAAnChG,EAAmC,SACK,IAAzCuB,OAAO0E,KAAKF,GAAUG,QAAQlG,IAAc8E,EAAO5D,EAAIlB,IAb9D,8BAiBD,IAAImG,EAAY/D,EAAGnB,SACfmF,EAAY/D,EAAGpB,SACnB,GAAyB,IAArBkF,EAAUjE,QAAqC,IAArBkE,EAAUlE,OAAc,OAKtD,IAHA,IAAImE,EAAO,EACPC,EAAKH,EAAUjE,OAAS,EACxBqE,EAAKH,EAAUlE,OAAS,EACrBmE,GAAQC,GAAMD,GAAQE,GAAMpE,EAAYgE,EAAUE,GAAOD,EAAUC,KACtEP,EAAMK,EAAUE,GAAOD,EAAUC,IACjCA,GAAQ,EAEZ,KAAOA,GAAQC,GAAMD,GAAQE,GAAMpE,EAAYgE,EAAUG,GAAKF,EAAUG,KACpET,EAAMK,EAAUG,GAAKF,EAAUG,IAC/BD,GAAM,EACNC,GAAM,EAEV,GAAIF,EAAOC,GAAMD,GAAQE,EACrB,KAAOF,GAAQE,GACXtB,EAAMmB,EAAUC,GAAOnF,GACvBmF,GAAQ,OAET,GAAIA,EAAOE,GAAMF,GAAQC,EAC5B,KAAOD,GAAQC,GACXxC,EAAGqC,EAAUE,GAAM/D,EAAEpB,GAAIA,GACzBmF,GAAQ,MAET,CAKH,IAJA,IAAIG,EAAQH,EACRI,EAAcF,EAAKC,EAAQ,EAC3BE,EAAiB,IAAIvG,IACrBwG,EAA6B,IAAIC,MAAMH,GAAaI,MAAM,GACrDC,EAAIN,EAAOM,GAAKP,EAAIO,IACrBV,EAAUU,GAAG9F,MAAML,KAAK+F,EAAexG,IAAIkG,EAAUU,GAAG9F,MAAML,IAAKmG,EAAIN,GAG/E,IAAK,IAAIM,EAAIN,EAAOM,GAAKR,EAAIQ,IAAK,CAC9B,IAAIC,GAAO,EACX,GAAK/E,EAAQmE,EAAUW,GAAG9F,MAAML,MAI5B,IAAK,IAAIqG,EAAIR,EAAOQ,GAAKT,EAAIS,IACzB,IAA+C,IAA3CL,EAA2BK,EAAIR,IAAiBrE,EAAYiE,EAAUY,GAAIb,EAAUW,IAAK,CACzFC,EAAMC,EAAIR,EACVV,EAAMK,EAAUW,GAAIV,EAAUY,IAC9B,YAPRD,EAAML,EAAe3G,IAAIoG,EAAUW,GAAG9F,MAAML,KAC5CmF,EAAMK,EAAUW,GAAIV,EAAUW,EAAMP,KAU3B,IAATO,EAGAjD,EAAGqC,EAAUW,GAAGxE,EAAEpB,GAAIA,GAEtByF,EAA2BI,GAAOD,EAAIN,EAM9C,IAHA,IAAIS,EF3FxB,SAAwB1C,GACpB,IAAI2C,EAAS,GACTC,EAAI5C,EAAI5C,QAEZ,SAASyF,EAAGC,GAIR,IAFA,IAAIC,EAAI,EACJC,EAAIL,EAAOhF,OAAS,EACjBoF,EAAIC,GAAG,CACV,IAAIC,EAAIC,KAAKC,OAAOJ,EAAIC,GAAK,GACzBhD,EAAI2C,EAAOM,KAAOH,EAAKE,EAAIC,EAC1BF,EAAIE,EAAI,EAEjB,OAAOF,EAGX,IAAK,IAAIR,EAAI,EAAGA,EAAIvC,EAAIrC,OAAQ4E,IAC5B,GAAsB,IAAlBI,EAAOhF,OACPgF,EAAOS,KAAKb,GACZK,EAAEL,GAAK,SACJ,CACH,IAAIC,EAAMK,EAAG7C,EAAIuC,IACbvC,EAAI2C,EAAOH,KAASxC,EAAIuC,GACZ,IAARC,GACAG,EAAOH,GAAOD,EACdK,EAAEL,GAAK,OAEPI,EAAOH,GAAOD,EACdK,EAAEL,GAAKI,EAAOH,EAAM,KAGxBI,EAAEL,GAAKI,EAAOA,EAAOhF,OAAS,GAC9BgF,EAAOS,KAAKb,IAOxB,IAFA,IAAIrC,EAAMyC,EAAOhF,OACb0F,EAAOV,EAAOA,EAAOhF,OAAS,GAC3BuC,EAAM,GAETyC,EADAzC,GAAO,GACOmD,EACdA,EAAOT,EAAED,EAAOzC,IAGpB,OAAOyC,EE8C2BW,CAAelB,GAC7BK,EAAIC,EAAY/E,OAAS,EAEpB4E,EAAIH,EAA2BzE,OAAS,EAAG4E,GAAK,EAAGA,IAAK,CAC7D,IAAIgB,EAAU1B,EAAUI,EAAQM,GAC5BrD,EAAS+C,EAAQM,EAAIV,EAAUlE,OAAS,EAAIkE,EAAUI,EAAQM,EAAI,GAAGxE,EAAEpB,QAAK6G,EAC5Ef,GAAK,GAAKC,EAAYD,KAAOF,EAE7BE,GAAK,GAIkC,IAAnCL,EAA2BG,GAE3B7B,EAAM6C,EAAS5G,EAAIuC,GAGnBuB,EAAK8C,EAAQxF,EAAEpB,GAAIA,EAAIuC,UAS/CgC,EAAQrD,EAAIC,I,ENlJdvB,EAAAA,OAgBY,CACV6B,QAAS,EACTD,KAAM,I,EAlBR5B,EAAAA,QAqBa,GOCnB,IAAMkH,EAAQ,CACVzF,EAAAA,EACA0F,WLAJ,SAASA,EAAW/C,GAChB,IAAInC,EAAMR,EAAE2C,EAAMnE,KAAMQ,OAAO2G,OAAO,GAAIhD,EAAMlE,OAAQkE,EAAMjE,SAAS2B,KAAI,SAAAC,GAAK,OAAIoF,EAAWpF,OAG/F,OAFAE,EAAIT,EAAEpB,GAAKgE,EAAM5C,EAAEpB,GACnB6B,EAAIT,EAAEjB,gBAAkB6D,EAAM5C,EAAEnB,MACzB4B,GKHPoF,UCZJ,SAAmBC,EAAWnF,GAC1B,IACIoF,EADAC,GAAU,EAEd5I,GAAO,WACH,IAAI6I,EAAUH,EAAUI,SACpBF,EACAxC,EAAMuC,EAAUE,IAEhBtD,EAAMsD,EAAStF,GACfqF,GAAU,GAEdD,EAAWE,MDEfE,UErBA,aAA0C,IAA9BC,EAA8B,uDAAvB,GAAIF,EAAmB,uDAAV,aAAU,UACtCnJ,KAAKqJ,KAAO9I,EAAS8I,GACrBrJ,KAAKmJ,OAASA,EAAOG,KAAKtJ,KAAKqJ,OFoBnC9I,SAAAA,EACAF,OAAAA,GAGJkJ,OAAOZ,MAAQA,G","sources":["webpack://MyVue/./src/reactive.js","webpack://MyVue/./src/VNode.js","webpack://MyVue/./src/is.js","webpack://MyVue/./src/h.js","webpack://MyVue/./src/domFuncs.js","webpack://MyVue/./src/utils.js","webpack://MyVue/./src/mount.js","webpack://MyVue/./src/patch_maxSequence.js","webpack://MyVue/./src/index.js","webpack://MyVue/./src/createApp.js","webpack://MyVue/./src/Component.js"],"sourcesContent":["let activeEffect = null;\r\nconst objsMap = new WeakMap();\r\n\r\nclass Dep {\r\n    constructor() {\r\n        this.dep = new Set();\r\n    }\r\n\r\n    add(e) {\r\n        this.dep.add(e);\r\n    }\r\n\r\n    trigger() {\r\n        for (let e of this.dep) {\r\n            e();\r\n        }\r\n    }\r\n};\r\n\r\nfunction effect(fn) {\r\n    activeEffect = fn;\r\n    fn(); // may use an reactive obj & cause get/set props opertation.\r\n    activeEffect = null;\r\n};\r\n\r\n\r\nfunction track(obj, prop) {\r\n    if (activeEffect !== null) {\r\n        if (!objsMap.has(obj)) objsMap.set(obj, new Map());\r\n        let depsMap = objsMap.get(obj);\r\n        if (!depsMap.has(prop)) depsMap.set(prop, new Dep());\r\n        let dep = depsMap.get(prop);\r\n        dep.add(activeEffect);\r\n    }\r\n};\r\n\r\nfunction trigger(obj, prop) {\r\n    if (objsMap.has(obj)) {\r\n        let depsMap = objsMap.get(obj);\r\n        if (depsMap.has(prop)) {\r\n            depsMap.get(prop).trigger();\r\n        }\r\n    }\r\n};\r\n\r\nfunction reTrackAllExcept(obj, prop) {\r\n    if (objsMap.has(obj)) {\r\n        let depsMap = objsMap.get(obj);\r\n        let effects = new Set();\r\n        for (let key of Reflect.ownKeys(obj)) {\r\n            if (depsMap.has(key) && key !== prop) {\r\n                let curEffects = depsMap.get(key).dep;\r\n                for (let effect of curEffects) {\r\n                    effects.add(effect);\r\n                    curEffects.delete(effect);\r\n                }\r\n            }\r\n        }\r\n        for (let e of effects) {\r\n            activeEffect = e;\r\n            e();\r\n        }\r\n    }\r\n}\r\n\r\nfunction reactive(obj) {\r\n    const reactiveObjHandler = {\r\n        get(obj, prop) {\r\n            track(obj, prop);\r\n            return typeof Reflect.get(obj, prop) === 'object' ? reactive(Reflect.get(obj, prop)) : Reflect.get(obj, prop);\r\n        },\r\n        set(obj, prop, value) {\r\n            if (!obj[prop]) {\r\n                Reflect.set(obj, prop, value);\r\n                reTrackAllExcept(obj, prop);\r\n                return true;\r\n            }\r\n            Reflect.set(obj, prop, value);\r\n            trigger(obj, prop);\r\n            return true;\r\n        }\r\n    };\r\n    return new Proxy(obj, reactiveObjHandler);\r\n};\r\n\r\nexport {\r\n    reactive,\r\n    effect,\r\n};","class VNode {\r\n\r\n    // private props: \r\n    _ = {\r\n        el: null,\r\n        type: null,\r\n        index: ++VNode.INDEX,\r\n        clonedFromIndex: 0,\r\n    };\r\n\r\n    constructor(type, props, children) {\r\n        this.type = type;\r\n        this.props = props;\r\n        this.children = children;\r\n    }\r\n\r\n    static TYPE = {\r\n        ELEMENT: 1,\r\n        TEXT: 1 << 1,\r\n    }\r\n\r\n    static INDEX = 0;\r\n}\r\n\r\nexport {\r\n    VNode\r\n};\r\n","function getType(e) {\r\n    return Object.prototype.toString.call(e).slice(8, -1);\r\n}\r\n\r\nfunction isHtmlElement(e) {\r\n    return e instanceof HTMLElement || e instanceof Text;\r\n}\r\n\r\nfunction isString(e) {\r\n    return getType(e) === 'String';\r\n}\r\n\r\nfunction isUndef(e) {\r\n    return e === void 0;\r\n}\r\n\r\nfunction isEmpty(e) {\r\n    if (getType(e) === 'Object') {\r\n        return Reflect.ownKeys(e).length === 0;\r\n    }\r\n    if (getType(e) === 'Array') {\r\n        return e.length === 0;\r\n    }\r\n}\r\n\r\nfunction isSameVNode(v1, v2) {\r\n    return v1._.type === v2._.type;\r\n    // && v1.props.key === v2.props.key\r\n}\r\n\r\nexport {\r\n    getType,\r\n    isHtmlElement,\r\n    isString,\r\n    isEmpty,\r\n    isUndef,\r\n    isSameVNode,\r\n};","import {\r\n    VNode\r\n} from './VNode.js';\r\nimport {\r\n    isEmpty,\r\n    isString,\r\n    getType,\r\n} from './is.js';\r\n\r\nfunction h(type, props = {}, children = []) {\r\n    let VNodeType = type === '' ? VNode.TYPE.TEXT : VNode.TYPE.ELEMENT;\r\n    if (!isEmpty(children)) {\r\n        children = children.map(child => {\r\n            if (isString(child)) return h('', {\r\n                text: child\r\n            }, []);\r\n            return child;\r\n        });\r\n    }\r\n    let res = new VNode(type, props, children);\r\n    res._.type = VNodeType;\r\n    return res;\r\n}\r\n\r\nfunction cloneVNode(vnode) {\r\n    let res = h(vnode.type, Object.assign({}, vnode.props), vnode.children.map(child => cloneVNode(child)));\r\n    res._.el = vnode._.el;\r\n    res._.clonedFromIndex = vnode._.index;\r\n    return res;\r\n}\r\n\r\nexport {\r\n    h,\r\n    cloneVNode,\r\n};","import {\r\n    isHtmlElement,\r\n    isString,\r\n    getType,\r\n} from './is.js';\r\nimport {\r\n    toKebab\r\n} from './utils.js';\r\n\r\nfunction qs(container, query) {\r\n    if (isString(container)) container = qs(document, container);\r\n    return container.querySelector(query);\r\n}\r\n\r\n// create DOM element.\r\nfunction ce(tag) {\r\n    return document.createElement(tag);\r\n}\r\n\r\n// create DOM fragment.\r\nfunction cf() {\r\n    return document.createDocumentFragment();\r\n}\r\n\r\n// create DOM Text Node.\r\nfunction ct(str) {\r\n    return document.createTextNode(str);\r\n}\r\n\r\nfunction append(elem, container) {\r\n    if (isString(container)) {\r\n        container = document.querySelector(container);\r\n    }\r\n    if (isHtmlElement(container)) container.appendChild(elem);\r\n}\r\n\r\nfunction insert(elem, container, anchor) {\r\n    if (!isHtmlElement(elem)) throw new Error('first para must be an HtmlElement object.');\r\n    if (isString(container)) {\r\n        container = qs(document, container);\r\n    };\r\n    if (isHtmlElement(container) && isString(anchor)) {\r\n        anchor = qs(container, anchor);\r\n    }\r\n    if (isHtmlElement(container) && isHtmlElement(anchor)) {\r\n        let isChild = false;\r\n        for (let i of container.childNodes) {\r\n            if (i === anchor) {\r\n                isChild = true;\r\n                break;\r\n            }\r\n        }\r\n        if (isChild) container.insertBefore(elem, anchor);\r\n        else throw new Error(`Can not insert element to an ancestor element.`);\r\n    }\r\n}\r\n\r\nfunction rm(elem, container) {\r\n    container.removeChild(elem);\r\n}\r\n\r\nfunction setAttr(elem, attr, value) {\r\n    if (!isString(attr)) throw new Error(`attr must be a string.`);\r\n    if (isString(elem)) elem = qs(document, elem);\r\n    if (!isHtmlElement(elem)) throw new Error(`Try setAttribute to a non HtmlElement.`);\r\n    if (attr.toLowerCase().slice(0, 2) === 'on') {\r\n        // event listener\r\n        if (getType(value) !== 'Function') throw new Error(`Try to addEventListener with a non function value.`);\r\n        let event = attr.slice(2).toLowerCase();\r\n        elem.removeEventListener(event, value);\r\n        elem.addEventListener(event, value);\r\n    } else {\r\n        attr = toKebab(attr);\r\n        elem.setAttribute(attr, value);\r\n    }\r\n}\r\n\r\nfunction rmAttr(elem, attr) {\r\n    if (!isString(attr)) throw new Error(`attr must be a string.`);\r\n    if (isString(elem)) elem = qs(document, elem);\r\n    if (!isHtmlElement(elem)) throw new Error(`Try setAttribute to a non HtmlElement.`);\r\n    elem.removeAttribute(attr);\r\n}\r\n\r\nfunction move(elem, container, anchor) {\r\n    rm(elem, container);\r\n    insert(elem, container, anchor);\r\n}\r\n\r\nexport {\r\n    ce,\r\n    cf,\r\n    ct,\r\n    qs,\r\n    rm,\r\n    rmAttr,\r\n    insert,\r\n    append,\r\n    setAttr,\r\n    move,\r\n};\r\n\r\n// // test\r\n// append(ce('input'), '#inner span');\r\n// let a = ce('button');\r\n// a.innerText = 'Good!';\r\n// insert(a, document.body, '#outer');","function toKebab(str) {\r\n    if (typeof str !== 'string') return '';\r\n    let arr = str.split('');\r\n    for (let cur = str.length - 1; cur >= 0; cur--) {\r\n        if (arr[cur] >= 'A' && arr[cur] <= 'Z') {\r\n            arr[cur] = arr[cur].toLowerCase();\r\n            arr.splice(cur, 0, '-');\r\n        }\r\n    }\r\n    return arr.join('');\r\n}\r\n\r\n// Get max asscending sequence of an pure number array.\r\n// getMaxSequence(arr);\r\n// eg. [2,3,6,1,7]  -> [2,3,6,7]\r\n\r\n// Algorithum (greedy) :\r\n// Time: O(n*logn)\r\n// Steps:\r\n//      1. Maintain an accending order array:[result], and an array:[p] whose length is the same with given array.\r\n//      2. result[i] = n, means that at current status, we have found a max accending sequence of length i+1, and the minimum number at the tail of the sequence is [n]. \r\n//      3. p[i] is setted when we take an element form the original given array and refresh the result array with it. p[i] records the previous number of result array of where we put the current element array[i] into at the result array;\r\n//      4. result array is an accending array, we iterate the original array and pick current element (arr[i]), then find the first element which is larger than current element in result array (assume that position is [pos]), and replace it with current element value;\r\n//      5. then we get the previous element of result array (result[pos-1]), and set p[i] with it;\r\n//      6. after we iterate all the elements, the last element of result array must be the real number of the max sequence, other elements can be replaced during the precess above, so they may be not the real number of the result max sequence;\r\n//      7. Luckily, we record the real element when we refresh every element of result, which is in array p. \r\n//      8. everytime, we get the element of result array, and find the position of it in the original array [pos], the real previous element of max subsquence  is p[pos];\r\n//      9. repeat the step.8 until all the sequence is found.\r\n\r\nfunction getMaxSequence(arr) {\r\n    let result = [];\r\n    let p = arr.slice(); // same length of arr.\r\n\r\n    function bs(tar) {\r\n        // find the first num which [ >= tar ].\r\n        let l = 0,\r\n            r = result.length - 1;\r\n        while (l < r) {\r\n            let m = Math.floor((l + r) / 2);\r\n            if (arr[result[m]] >= tar) r = m;\r\n            else l = m + 1;\r\n        }\r\n        return l;\r\n    }\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (result.length === 0) {\r\n            result.push(i);\r\n            p[i] = null;\r\n        } else {\r\n            let pos = bs(arr[i]);\r\n            if (arr[result[pos]] >= arr[i]) {\r\n                if (pos === 0) {\r\n                    result[pos] = i;\r\n                    p[i] = null;\r\n                } else {\r\n                    result[pos] = i;\r\n                    p[i] = result[pos - 1];\r\n                }\r\n            } else {\r\n                p[i] = result[result.length - 1];\r\n                result.push(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    let cur = result.length;\r\n    let prev = result[result.length - 1];\r\n    while (cur > 0) {\r\n        cur -= 1;\r\n        result[cur] = prev;\r\n        prev = p[result[cur]];\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport {\r\n    toKebab,\r\n    getMaxSequence,\r\n};","import {\r\n    VNode\r\n} from './VNode.js';\r\nimport {\r\n    isEmpty,\r\n    isUndef,\r\n    isString,\r\n} from './is.js';\r\nimport {\r\n    h\r\n} from './h.js';\r\nimport * as dom from './domFuncs.js';\r\n\r\nfunction mount(vnode, container, anchor) {\r\n    if (isUndef(vnode)) {\r\n        console.warn(`There are something undefined when mounting a VNode. (You may try to modify an array's length larger directly.)`);\r\n        vnode = h('', {}, ['undefined']);\r\n    }\r\n    if (vnode._.type & VNode.TYPE.ELEMENT) {\r\n        let tag = vnode.type;\r\n        let {\r\n            props,\r\n            children\r\n        } = vnode;\r\n        let el = dom.ce(tag);\r\n        vnode._.el = el;\r\n        if (!isEmpty(props)) {\r\n            for (let prop of Reflect.ownKeys(props)) {\r\n                dom.setAttr(el, prop, Reflect.get(props, prop));\r\n            }\r\n        }\r\n        if (!isEmpty(children)) {\r\n            for (let child of children) {\r\n                mount(child, el);\r\n            }\r\n        }\r\n        if (isUndef(anchor)) dom.append(el, container);\r\n        else dom.insert(el, container, anchor);\r\n    } else if (vnode._.type & VNode.TYPE.TEXT) {\r\n        let text = vnode.props.text;\r\n        let el = dom.ct(text);\r\n        vnode._.el = el;\r\n        if (isUndef(anchor)) dom.append(el, container);\r\n        else dom.insert(el, container, anchor);\r\n    }\r\n}\r\n\r\nexport {\r\n    mount,\r\n};","import {\r\n    VNode\r\n} from './VNode.js';\r\nimport {\r\n    mount\r\n} from './mount.js';\r\nimport {\r\n    rm,\r\n    rmAttr,\r\n    setAttr,\r\n    move,\r\n} from './domFuncs.js';\r\nimport {\r\n    getMaxSequence,\r\n    toKebab,\r\n} from './utils.js';\r\nimport {\r\n    isUndef,\r\n    isSameVNode,\r\n} from './is.js';\r\n\r\nfunction replace(v1, v2) {\r\n    if ((v1._.type & VNode.TYPE.TEXT) && (v2._.type & VNode.TYPE.TEXT)) {\r\n        v1._.el.nodeValue = v2.props.text;\r\n        v2._.el = v1._.el;\r\n        return;\r\n    }\r\n    let parent = v1._.el.parentNode;\r\n    let anchor = v1._.el.nextSibling || void 0;\r\n    parent.removeChild(v1._.el);\r\n    mount(v2, parent, anchor);\r\n}\r\n\r\nfunction patch(v1, v2) {\r\n    if (isUndef(v1) || isUndef(v2)) {\r\n        // console.log(v1,v2);\r\n        console.warn(`There are something undefined when patching a VNode. (You may try to modify an array's length larger directly.)`);\r\n        return;\r\n    }\r\n    let el = v1._.el;\r\n    if (v1._.type === v2._.type) {\r\n        if (v1._.type & VNode.TYPE.TEXT) {\r\n            if (v1.props.text !== v2.props.text) replace(v1, v2);\r\n            else v2._.el = el;\r\n        } else {\r\n            if (v1.type !== v2.type) replace(v1, v2);\r\n            else {\r\n                // diff algorithum.\r\n                // diff props.\r\n                v2._.el = el;\r\n                let newProps = v2.props;\r\n                let oldProps = v1.props;\r\n                for (let prop of Reflect.ownKeys(newProps)) {\r\n                    if (oldProps[prop] !== newProps[prop]) {\r\n                        if (newProps[prop] === null) rmAttr(el, prop);\r\n                        else setAttr(el, prop, newProps[prop]);\r\n                    }\r\n                }\r\n                for (let prop of Reflect.ownKeys(oldProps)) {\r\n                    if (Object.keys(newProps).indexOf(prop) === -1) rmAttr(el, prop);\r\n                }\r\n\r\n                // diff children._.index is at accending order !!!! -- Mars 2021.09.07\r\n                let children1 = v1.children,\r\n                    children2 = v2.children;\r\n                if (children1.length === 0 && children2.length === 0) return;\r\n                // max sequence algorithum.\r\n                let head = 0;\r\n                let e1 = children1.length - 1,\r\n                    e2 = children2.length - 1;\r\n                while (head <= e1 && head <= e2 && isSameVNode(children1[head], children2[head])) {\r\n                    patch(children1[head], children2[head]);\r\n                    head += 1;\r\n                }\r\n                while (head <= e1 && head <= e2 && isSameVNode(children1[e1], children2[e2])) {\r\n                    patch(children1[e1], children2[e2]);\r\n                    e1 -= 1;\r\n                    e2 -= 1;\r\n                }\r\n                if (head > e1 && head <= e2) {\r\n                    while (head <= e2) {\r\n                        mount(children2[head], el);\r\n                        head += 1;\r\n                    }\r\n                } else if (head > e2 && head <= e1) {\r\n                    while (head <= e1) {\r\n                        rm(children1[head]._.el, el);\r\n                        head += 1;\r\n                    }\r\n                } else {\r\n                    let start = head;\r\n                    let totalLength = e2 - start + 1;\r\n                    let newChildrenMap = new Map();\r\n                    let newChildPositionInOldChild = new Array(totalLength).fill(-1);\r\n                    for (let i = start; i <= e2; i++) {\r\n                        if (children2[i].props.key) newChildrenMap.set(children2[i].props.key, i - start);\r\n                    }\r\n                    // find new child position in old children array.\r\n                    for (let i = start; i <= e1; i++) {\r\n                        let pos = -1;\r\n                        if (!isUndef(children1[i].props.key)) {\r\n                            pos = newChildrenMap.get(children1[i].props.key);\r\n                            patch(children1[i], children2[pos + start]);\r\n                        } else {\r\n                            for (let j = start; j <= e2; j++) {\r\n                                if (newChildPositionInOldChild[j - start] === -1 && isSameVNode(children2[j], children1[i])) {\r\n                                    pos = j - start;\r\n                                    patch(children1[i], children2[j]);\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (pos === -1) {\r\n                            // console.log(`deleted at old position ${i}.`);\r\n                            // console.log(children1[i]);\r\n                            rm(children1[i]._.el, el);\r\n                        } else {\r\n                            newChildPositionInOldChild[pos] = i - start;\r\n                        }\r\n                    }\r\n                    let maxSequence = getMaxSequence(newChildPositionInOldChild);\r\n                    let j = maxSequence.length - 1;\r\n                    // console.log(v1,v2, newChildrenMap, newChildPositionInOldChild, maxSequence);\r\n                    for (let i = newChildPositionInOldChild.length - 1; i >= 0; i--) {\r\n                        let curNode = children2[start + i];\r\n                        let anchor = start + i < children2.length - 1 ? children2[start + i + 1]._.el : undefined;\r\n                        if (j >= 0 && maxSequence[j] === i) {\r\n                            // exist in maxSequence, has been patched, and no need to move.\r\n                            j -= 1;\r\n                            // console.log(curNode.props.key + ' is stable!');\r\n                            continue;\r\n                        } else {\r\n                            if (newChildPositionInOldChild[i] === -1) {\r\n                                // new vnode in children2 and not exist in children1;\r\n                                mount(curNode, el, anchor);\r\n                            } else {\r\n                                // not exist in maxSequence, has been patched, need to move.\r\n                                move(curNode._.el, el, anchor);\r\n                                // console.log(`${curNode.props.key} is moved to ahead of ${anchor.innerText}`);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        replace(v1, v2);\r\n    }\r\n}\r\n\r\nexport {\r\n    patch\r\n};","import {\r\n    reactive,\r\n    effect,\r\n}\r\nfrom './reactive.js';\r\n\r\nimport {\r\n    Component,\r\n}\r\nfrom './Component.js';\r\n\r\nimport {\r\n    createApp,\r\n}\r\nfrom './createApp.js';\r\n\r\nimport {\r\n    h,\r\n    cloneVNode,\r\n}\r\nfrom './h.js';\r\n\r\nconst myVue = {\r\n    h,\r\n    cloneVNode,\r\n    createApp,\r\n    Component,\r\n    reactive,\r\n    effect,\r\n};\r\n\r\nwindow.myVue = myVue;","import {\r\n    reactive,\r\n    effect,\r\n} from './reactive.js';\r\n\r\nimport {\r\n    mount\r\n} from './mount.js';\r\n\r\nimport {\r\n    patch\r\n} from './patch_maxSequence.js';\r\n\r\nfunction createApp(component, container) {\r\n    let mounted = false;\r\n    let prevTree;\r\n    effect(() => {\r\n        let newTree = component.render();\r\n        if (mounted) {\r\n            patch(prevTree, newTree);\r\n        } else {\r\n            mount(newTree, container);\r\n            mounted = true;\r\n        }\r\n        prevTree = newTree;\r\n    });\r\n}\r\n\r\nexport {\r\n    createApp,\r\n};","import {\r\n    reactive,\r\n} from './reactive.js';\r\n\r\nclass Component {\r\n    constructor(data = {}, render = () => {}) {\r\n        this.data = reactive(data);\r\n        this.render = render.bind(this.data);\r\n    }\r\n}\r\n\r\nexport {\r\n    Component,\r\n};"],"names":["activeEffect","objsMap","WeakMap","Dep","this","dep","Set","e","add","effect","fn","reactive","obj","Proxy","get","prop","has","set","Map","depsMap","track","Reflect","value","trigger","effects","ownKeys","key","curEffects","reTrackAllExcept","VNode","type","props","children","el","index","INDEX","clonedFromIndex","getType","Object","prototype","toString","call","slice","isHtmlElement","HTMLElement","Text","isString","isUndef","isEmpty","length","isSameVNode","v1","v2","_","h","VNodeType","TYPE","TEXT","ELEMENT","map","child","text","res","qs","container","query","document","querySelector","append","elem","appendChild","insert","anchor","Error","isChild","childNodes","insertBefore","rm","removeChild","setAttr","attr","toLowerCase","event","removeEventListener","addEventListener","str","arr","split","cur","splice","join","toKebab","setAttribute","rmAttr","removeAttribute","move","mount","vnode","console","warn","tag","createElement","dom","createTextNode","replace","nodeValue","parent","parentNode","nextSibling","patch","newProps","oldProps","keys","indexOf","children1","children2","head","e1","e2","start","totalLength","newChildrenMap","newChildPositionInOldChild","Array","fill","i","pos","j","maxSequence","result","p","bs","tar","l","r","m","Math","floor","push","prev","getMaxSequence","curNode","undefined","myVue","cloneVNode","assign","createApp","component","prevTree","mounted","newTree","render","Component","data","bind","window"],"sourceRoot":""}